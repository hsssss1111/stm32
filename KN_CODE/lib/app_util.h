/****************************************Copyright (c)****************************************************
**                         							ZhangZhou KENENG electronics Co.,LTD.
**
**
**
**--------------File Info---------------------------------------------------------------------------------
** File name:			app_util.h
** Last modified Date:  2009-05-15
** Last Version:		1.0
** Descriptions:		提供给APP层进行调用的一些公共函数接口
**
**--------------------------------------------------------------------------------------------------------
** Created by:		heshusheng
** Created date:		2009-05-15
** Version:				1.0
** Descriptions:		The original version
**
**--------------------------------------------------------------------------------------------------------
	2009-05-27  by heshusheng		  add function app_checksum.
	2009-06-03  by heshusheng       add function app_hex_reverse.

*********************************************************************************************************/

#ifndef	_APP_UTIL_H_
#define	_APP_UTIL_H_

#include <time.h>

#define	SEC_PER_DAY	0x00015180
#define	MIN5_IN_SEC	0x12c
#define	ASIZE(x)	 (sizeof(x)/sizeof(x[0]))

// 计算两个时钟节拍之间相差秒数(TIME1,TIME2为系统时钟节拍计数器,最大值为0xFFFFFFFF)
#define TIME_DIFF_SEC(TIME1,TIME2) ( (TIME1 > TIME2 ? 0xFFFFFFFF - TIME1 + TIME2 : TIME2 - TIME1) / OS_TICKS_PER_SEC )

// 计算两个时钟节拍之间相差(TIME1,TIME2为系统时钟节拍计数器,最大值为0xFFFFFFFF)
#define TIME_DIFF_TICK(TIME1,TIME2) ( TIME1 > TIME2 ? 0xFFFFFFFF - TIME1 + TIME2 : TIME2 - TIME1 )

// 计算两个时钟节拍之间相差毫数(TIME1,TIME2为系统时钟节拍计数器,最大值为0xFFFFFFFF)
#define TIME_DIFF_MS(TIME1,TIME2) ( (TIME1 > TIME2 ? 0xFFFFFFFF - TIME1 + TIME2 : TIME2 - TIME1) * (1000 / OS_TICKS_PER_SEC))

// 位操作宏定义
#define BitGet(Number,Pos) ((Number >> Pos) & 1)   //得到某数的某位
#define BitSet(Number,Pos) (Number |= (1<<(Pos)))  //把某位置1
#define BitClr(Number,Pos) (Number &= ~(1<<(Pos))) //把某位置0
#define BitRes(Number,Pos) (Number ^= (1<<(Pos)))  //把Number的POS位取反

#define MinTwo(a,b) ((a < b) ? a : b) //获取二个数中的最小值
#define MaxTwo(a,b) ((a > b) ? a : b) //获取二个数中的最大值
#define MinThr(a,b,c) (MinTwo(MinTwo(a,b), c))  //获取三个数中的最小值
#define MaxThr(a,b,c) (MaxTwo(MaxTwo(a,b), c))  //获取三个数中的最dd  值

#define DSECOND 1 //秒
#define DMINUTE 2 //分
#define DHOUR 3   //时
#define DDAY 4    //日
#define DMONTH 5  //月
#define DYEAR 6   //年
#define DWEEK 7   //周

/*********************************************************************************************************
* 名    称：app_crc32
* 功    能：CRC32位校验
* 入口参数:crc:校验前的值
						buf:数据缓存
						len:有效数据长度
							
* 出口参数:计算后的CRC的值
**********************************************************************************************************/
uint32 app_crc32 (uint32 crc, const char *buf, uint32 len);

/*********************************************************************************************************
* 名    称：app_crc16
* 功    能：CRC16位校验
* 入口参数:
						buf:数据缓存
						len:有效数据长度
							
* 出口参数:计算后的CRC的值
**********************************************************************************************************/
uint16 app_crc16(uint8 *buf, int len);

/*********************************************************************************************************
* 名    称：app_crc16_r
* 功    能：高位 CRC16位校验
* 入口参数:
						buf:数据缓存
						len:有效数据长度
							
* 出口参数:计算后的CRC的值
**********************************************************************************************************/
uint16 app_crc16_r(uint8 *buf, int len);

/*********************************************************************************************************
* 名    称：app_itoa
* 功    能：n进制编码到asc编码的转换
* 入口参数: v:待转换的n进制数
						 s:转换后的asc码
						 r:v数据是r进制的；
						 h:预留的数据位数，如不够则前面补asc字符'0'
						 flag:返回的单个数据的长度
* 出口参数:指向返回数据的下一个地址
**********************************************************************************************************/
int8 app_atoi
(
  void *val_arg_ptr,      /*  value returned  */
  char *s,                        /*  points to string to eval  */
  unsigned int r,                        /*  radix */
  uint8 flag
);

/*********************************************************************************************************
* 名    称：app_atoi
* 功    能：asc 到n进制编码的转换
* 入口参数: val_arg_ptr:指向返回存储的数据域
							s:指向待处理的字符串，(遇空格区分数据)
							r:返回数据是r进制的
							
* 出口参数:解析得到的数据个数
**********************************************************************************************************/
char *app_itoa(uint32 v,char *s,uint16 r,uint8 h);

/*********************************************************************************************************
* 名    称：app_checksum
* 功    能：计算校验和
* 入口参数：src:信息域起始指针
							len:信息域长度
* 出口参数:返回校验和数据
**********************************************************************************************************/
uint8 app_checksum(int8 *src, uint32 len);

/*********************************************************************************************************
* 名    称：app_hex_reverse
* 功    能：将hex信息进行反序处理
* 入口参数：pdata:信息起始指针
							len:信息域长度
* 出口参数:0-成功  1-失败
**********************************************************************************************************/
uint8 app_hex_reverse(uint8 *pdata, uint16 len);

/*********************************************************************************************************
* 名    称：app_timeconv
* 功    能：将存储的时间格式转化为计算的时间大小
* 入口参数：time:指向时间存储指针
							
* 出口参数:返回计算的偏移时间
**********************************************************************************************************/
time_t app_timeconv( uint8 *time);

/*********************************************************************************************************
* 名    称：app_timereconv
* 功    能：将计算时间的大小转换为标准时间格式
* 入口参数：src:计算时间的大小
							
* 出口参数:time:返回标准时间格式
**********************************************************************************************************/
int8 app_timereconv( uint8 *time, time_t sr);

/*********************************************************************************************************
* 名    称：app_timeconv
* 功    能：将存储的时间格式转化为计算的时间大小
* 入口参数：time:指向时间存储指针BCD(ssmmHHddMMyy)

* 出口参数:返回计算的偏移时间
**********************************************************************************************************/
time_t app_bcdtimetotimet(uint8 *time);

/**********************************************************************************
 * 函数名称：app_findbytes
 * 函数功能：查询某数据串中是否有指定的数据串
 * 输入参数: buf uint8  源数据串缓冲区指针地址
 * 输入参数：len uint8  源数据串缓冲区长度
 * 输入参数：needle uint8 目标数据串缓冲区指针地址
 * 输出参数:  pos对应的字符串的起始位置
 * 返  回   值：1找到对应的字符串??,0:未找到指定数据串
 **********************************************************************************/
uint8 app_findbytes(uint8 *buf, uint32 len, uint8 *needle, uint16 *pos );

//bcd 编码到asc码的转换
//len 为指定转换后的长度
int8 app_bcdtoa(char *asc, char *bcd, int len, int fmt);

//asc ii 到 BCD 编码的转换
int app_atobcd(char *bcd, char *asc, int len, int fmt);

/*******************************************************
 * 函数功能:获取电话号码或手机号码
 * 函数名称:app_getphone(uint8 *phone,uint8 *inbuf,uint8 len)
 * 输入参数:pstr 末解码的号码数据
 * 输入参数:len 末解码的号码数据长度
 * 输出参数:pdtr 解码后的号码
 * 返   回  值:1 成功,0:失败
 *******************************************************/
int8 app_getphone(uint8 *pdtr,uint8 *pstr,uint8 len);

/*******************************************************
 * 函数功能:判断日期是否有效
 * 函数名称:app_isDate
 * 输入参数:年，月，日
 * 返   回  值:1有效,0无效
 *******************************************************/
int8 app_isdate(int16 y, int16 m, int16 d);

/*******************************************************
 * 函数功能:计算time_t类型相对日期时间
 * 函数名称:app_dateadd
 * 输入参数:<u8Interval>[uint8] 单位
 * 输入参数:<s32Nt>[int32] 相对量
 * 输入参数:<tTime>[time_t] 日期时间
 * 返   回  值:time_t
 *******************************************************/
time_t app_dateadd(uint8 u8Interval, int32 s32Nt, time_t tTime);

/*******************************************************
 * 函数功能：可打印字符串转换为字节数据(如“C8329B” --> {0xC8,0x32,0x98})
 * 函数名称：StringToBytes(uint8 * pDst,const uint8 * pSrc,int32 nSrcLength)
 * 输出参数：pDst uint8 目标字符串指针
 * 输入参数：pSrc uint8 源字符串指针
 * 输入参数：nSrcLength int32 源字符串长度
 * 返 回 值：>0 目标字符串长度,-1 转换错误
 ******************************************************/
int32 StringToBytes(uint8 * pDst,const uint8 * pSrc,int32 nSrcLength);

/*******************************************************
 * 函数功能：字节数据转换为可打印字符串(如 {0xC8,0x32,0x98} --> "C8329B")
 * 函数名称：int32 BytesToString(uint8 * pDst , const uint8 * pSrc, int32 nSrcLength)
 * 输出参数：pDst uint8 目标字符串指针
 * 输入参数：pSrc uint8 源字符串指针
 * 输入参数：nSrcLength int32 源字符串长度
 * 返 回 值：目标字符串长度,-1 转换错误
 ******************************************************/
int32 BytesToString(uint8 * pDst,const uint8 * pSrc,int32 nSrcLength);

/*******************************************************
 * 函数功能：两两颠倒的字符串转换为正常顺序的字符串
 * 函数名称：int32 SerializeNumber(uint8 * pDst,const uint8 * pSrc,const int8 nSMSFlag,int32 nSrcLength)
 * 输出参数：pDst uint8 目标字符串指针
 * 输入参数：pSrc uint8 源字符串指针
 * 输入参数：nSMSFlag int8 短消息号码转换标志(683195595682F1->8613599565281)
 * 输入参数：nSrcLength int32 源字符串长度
 * 返  回  值：目标字符串长度
 ******************************************************/
int32 SerializeNumber(uint8 * pDst,const uint8 * pSrc,const int8 nSMSFlag,int32 nSrcLength);

/*******************************************************
 * 函数功能：正常顺序的字符串转换为两两颠倒的字符串(长度为奇数，补'F'凑成偶数)
 * 函数名称：int32 InvertNumbers(uint8 * pDst , const uint8 * pSrc, const int8 nSMSFlag, int32 nSrcLength)
 * 输出参数：pDst uint8 目标字符串指针
 * 输入参数：pSrc uint8 源字符串指针
 * 输入参数：nSMSFlag int8 短消息号码转换标志(8613599565281->683195595682F1)
 * 输入参数：nSrcLength int32 源字符串长度
 * 返 回 值：目标字符串长度
 ******************************************************/
int32 InvertNumbers(uint8 * pDst , const uint8 * pSrc, const int8 nSMSFlag, int32 nSrcLength);

/*******************************************************
 * 函数功能:幂运算
 * 函数名称:PowerCal
 * 输入参数:<s32Origianl>[int] 被乘方数
 * 输出参数:<s32Power>[int] 幂运算次数
 * 返   回  值:幂运算结果
 *******************************************************/
int32 PowerCal(int s32Origianl, int s32Power);

/*******************************************************
 * 函数功能:获取字节中有效位数
 * 函数名称:ValidBitCount
 * 输入参数:<u8Byte>[uint8] 被计算的字节
 * 输出参数:无
 * 返   回  值:有效位个数
 *******************************************************/
uint8 ValidBitCount(uint8 u8Byte);

/*******************************************************
 * 函数功能:BCD 码转换成 HEX 码
 * 函数名称:BCD2HEX
 * 输入参数:<pData>[uint8 *] 被转换的数据
 * 输入参数:<u16Len>[uint16] 被转换的数据长度
 * 返   回  值:有效位个数
 *******************************************************/
uint8 * BCD2HEX(uint8 * pData, const uint16 u16Len);

/*******************************************************
 * 函数功能:HEX 码转换成 BCD 码
 * 函数名称:HEX2BCD
 * 输入参数:<pData>[uint8 *] 被转换的数据
 * 输入参数:<u16Len>[uint16] 被转换的数据长度
 * 返   回  值:有效位个数
 *******************************************************/
uint8 * HEX2BCD(uint8 *pData, const uint16 u16Len);

 /*******************************************************
 * 函数功能:时间格式转换
 * 函数名称:TimeFormatStr
 * 输出参数:<TimeFlag>[uint8 *] 输出时间格式BCD
 * 输入参数:<FormatTime>[time_t]  被转换的时间
 * 输入参数:<ReverSe>[uint8]  是否次序颠倒
 * 返   回  值:无
 *******************************************************/
int8 TimeFormatStr(uint8 *TimeFlag, time_t FormatTime, uint8 Reverse);

/*******************************************************
* 函数功能:从RTC获取时间将转为BCD格式
* 函数名称:RtctimeToBcd
* 输出参数:<pTime>[uint8 *] 输出时间格式BCD
* 输入参数:<ReverSe>[uint8]  是否次序颠倒ssmmhhddMMyy
* 返   回  值:无
*******************************************************/
int8 RtctimeToBcd(uint8 Reverse, uint8 *pTime);

/*******************************************************
* 函数功能:获取当前系统时钟time_t格式
* 函数名称:GetTime
* 返   回  值:当前系统时间time_t
*******************************************************/
time_t GetTime(void);

/*******************************************************
 * 函数功能:获取信息类对应的信息类属性表索引号
 * 函数名称:app_getdtprono
 * 输入参数:<u16Dt>[uint16] 信息类标志
 * 返   回  值:信息类属性表索引号
 *******************************************************/
uint16 app_getdtprono(uint16 u16Dt);

/*******************************************************
 * 函数功能:冻结密度类型转为秒
 * 函数名称:app_densitytosec
 * 输入参数:<u8Density>[uint8] 冻结密度
 * 返   回  值:冻结密度对应的秒数
 *******************************************************/
uint16 app_densitytosec(uint8 u8Density);

/*******************************************************
 * 函数功能:冻结密度类型转为分钟
 * 函数名称:app_densitytomin
 * 输入参数:<u8Density>[uint8] 冻结密度
 * 返   回  值:冻结密度对应的秒数
 *******************************************************/
uint16 app_densitytomin(uint8 u8Density);

/*******************************************************
 * 函数功能:冻结密度转换
 * 函数名称:app_dinsitytomd
 * 返   回  值:协议冻结密度
 *******************************************************/
uint8 app_dinsitytomd(uint8 u8Density);

//在一段内存缓冲中查找指定字符串的位置，从头开始查找，不区分大小写。
//返回第一个找到的位置。
//str1 - 内存缓冲的头指针
//nLen1 - 内存缓冲长度
//str2 - 要查找匹配的字符串
uint8 * memstr( uint8 * str1, uint32 nLen1,  uint8 * str2);

/*******************************************************
 * 函数功能:时间格式修整(将单位时间后的余数置0)
 * 函数名称:app_datetrim
 * 输入参数:<interUnit>[uint8] 单位(1秒, 2分, 3时, 4日, 5月)
 * 输入参数:<date1>[time_t]  待修整的时间
 * 返   回  值:修整后的时间
 *******************************************************/
time_t app_datetrim(uint8 interUnit,const time_t date);

/*******************************************************
 * 函数功能:计算两个时间单位差值
 * 函数名称:app_bcd5datediff
 * 输入参数:<interUnit>[uint8] 单位(1秒, 2分, 3时, 4日, 5月)
 * 输入参数:<date1>[time_t]  起始时间
 * 输入参数:<date2>[time_t]  结束时间
 * 返   回  值:单位差值
 *******************************************************/
int32 app_datediff(uint8 interUnit, const time_t date1,const time_t date2);

/*******************************************************
 * 函数功能:计算两个时间单位差值
 * 函数名称:app_bcd5datediff
 * 输入参数:<interUnit>[uint8] 单位(2分, 3时, 4日, 5月)
 * 输入参数:<bcdTime1>[uint8 *]  起始时间
 * 输入参数:<bcdTime2>[uint8 *]  结束时间
 * 返   回  值:单位差值
 *******************************************************/
int32 app_bcd5datediff(uint8 interUnit, const uint8 *bcdTime1, const uint8 *bcdTime2);

/*******************************************************
 * 函数功能:时间向前跳跃
 * 函数名称:app_upboundtime
 * 输入参数:<tEndTime>[time_t] 结束时间
 * 输入参数:<tStdTime>[time_t] 起始时间
 * 输入参数:<interUnit>[uint8] 单位(2分, 3时, 4日, 5月)
 * 输入参数:<interVal>[uint32] 周期
 * 返   回  值:跳跃后的时间
 *******************************************************/
time_t app_upboundtime(time_t tEndTime, time_t tStdTime, uint8 interUnit, uint32 interVal);

/*******************************************************
 * 函数功能:时间向后跳跃
 * 函数名称:app_downboundtime
 * 输入参数:<tEndTime>[time_t] 结束时间
 * 输入参数:<tStdTime>[time_t] 起始时间
 * 输入参数:<interUnit>[uint8] 单位(2分, 3时, 4日, 5月)
 * 输入参数:<interVal>[uint32] 周期
 * 返   回  值:跳跃后的时间
 *******************************************************/
time_t app_downboundtime(time_t tEndTime, time_t tStdTime, uint8 interUnit, int32 interVal);

/*******************************************************
 * 函数功能:电量计算并做过零判断
 * 函数名称:app_countelectricity
 * 输入参数:<fpStart>[fp64] 起码
 * 输入参数:<fpEnd>[fp64]   止码
 * 输入参数:<u8IntegerNum>[uint8]  电能示值整数位个数
 * 输出参数:<pEnergy>[fp64 *]  电能量
 * 返   回  值:-2 示度异常, -3 示度下降, 0 正常
 *******************************************************/
int8 app_countelectricity(fp64 fpStart, fp64 fpEnd, uint8 u8IntegerNum, fp64 *pEnergy);

/*******************************************************
 * 函数功能:求浮点数绝对值
 * 函数名称:app_fabs
 * 输入参数:<fpVal>[fp64] 浮点数
 * 返   回  值:浮点数绝对值
 *******************************************************/
fp64 app_fabs(fp64 fpVal);

/*******************************************************
 * 函数功能:获取字节中指定位置前有效位数
 * 函数名称:ValidBitCount
 * 输入参数:<u8Byte>[uint8] 被计算的字节
 * 输入参数:<u8End>[uint8] 指定位
 * 输出参数:无
 * 返   回  值:有效位个数
 *******************************************************/
uint8 BefValidBitCount(uint8 u8Byte, uint8 u8End);


//其他进制转化为10进制
//输入参数:
// buf_src   输入缓冲区
// src_digit 转化数的进制
// 返回值:
//      转换后的10进制数
long int app_otdec(unsigned char *buf_src, int src_digit);

/*******************************************************
 * 函数功能:时间格式转为Time_t类型
 * 函数名称:app_mktime
 * 输入参数:<pStTm>[struct tm *] 时钟格式
 * 返   回  值:转换后的时间
 *******************************************************/
time_t app_mktime(struct tm *pStTm);

/*******************************************************
 * 函数功能:时间格式转为Time_t转为tm
 * 函数名称:app_mktime
 * 输入参数:<pStTm>[struct tm *] 时钟格式
 * 返   回  值:转换后的时间
 *******************************************************/
int8 app_localtime(struct tm *ptm, time_t tTime);

/*******************************************************
 * 函数功能:公用函数库初始化
 * 函数名称:app_init
 * 返   回  值:无
 *******************************************************/
void app_init(void *param);

#endif /*_APP_UTIL_H_*/

